package services

import (
	"rnd-surajan-gin/dtos"
	"rnd-surajan-gin/infrastructure"
	"rnd-surajan-gin/models"
	"rnd-surajan-gin/pagination"

	"gorm.io/gorm"
)

// Dependency Injection
type TaskService struct {
	db infrastructure.Database
}

func NewTaskService(db infrastructure.Database) TaskService {
	return TaskService{db: db}
}

func (cc TaskService) CreateTask(task models.Task) (data models.Task, err error) {
	return task, cc.db.DB.Create(&task).Error
}

func (cc TaskService) GetAllTasks(pageNo, pageSize string, defaultPageSize int, count *int64) (data []models.Task, totalDataResult *gorm.DB, result *gorm.DB) {
	var tasks []models.Task
	// Using Gorm scopes, we can reuse query logic, like the pagination logic => db.Offset().Limit()
	// The .Count(count) counts total data in our database.
	return tasks, cc.db.DB.Find(&tasks).Count(count), cc.db.DB.Scopes(pagination.Paginate(pageNo, pageSize, defaultPageSize)).Find(&tasks)
}

func (cc TaskService) GetTaskById(id string) (data models.Task, result *gorm.DB) {
	var task models.Task
	// The commented code only works when our "id" is automatically generated by GORM and is an auto-incremented number.
	// result := cc.db.DB.First(&task, id)
	return task, cc.db.DB.Where("id = ?", id).First(&task)
}

func (cc TaskService) UpdateTaskById(id string, payload dtos.UpdateTaskRequest) (data models.Task, findErr error, updateErr error) {
	// Get Task by id i.e. Primary Key.
	var task models.Task
	// This code only works when our "id" is automatically generated by GORM and is an auto-incremented number.
	// result := cc.db.DB.First(&task, id)
	result := cc.db.DB.Where("id = ?", id).First(&task)
	// Update "task" model with the given "payload".
	updateResult := cc.db.DB.Model(&task).Updates(payload)
	return task, result.Error, updateResult.Error
}

func (cc TaskService) DeleteTaskById(id string) (result *gorm.DB) {
	// Delete Task by id i.e. Primary Key.
	var task models.Task
	/*
		ðŸ’¡Note: If not used "Unscoped()", then "Delete()" will only do soft-delete because our "tasks" table contain "deleted_at" column.
		When we created our "Task" model, we included "gorm.Model" which will append "deleted_at" column in our "tasks" table.
		See: https://gorm.io/docs/delete.html#Soft-Delete for more info.
	*/
	// This code only works when our "id" is automatically generated by GORM and is an auto-incremented number.
	// result := cc.db.DB.Unscoped().Delete(&task, id)
	return cc.db.DB.Where("id = ?", id).Unscoped().Delete(&task)
}

func (cc TaskService) UpdateTaskStatus(id string, userId string, newStatus string) (data models.Task, findErr error, updateErr error) {
	// Get Task by id i.e. Primary Key.
	var task models.Task
	// Only that user who owns this task can update it's status
	result := cc.db.DB.Where("id = ? AND user_id = ?", id, userId).First(&task)
	// Update status
	updateResult := cc.db.DB.Model(&task).Update("status", newStatus)
	return task, result.Error, updateResult.Error
}

func (cc TaskService) GetTaskByUserIdAndStatus(userId string, status string) (data []models.Task, result *gorm.DB) {
	var tasks []models.Task
	query := cc.db.DB.Where("user_id = ?", userId)
	if status != "" {
		query = cc.db.DB.Where("user_id = ? AND status = ?", userId, status)
	}
	return tasks, query.Find(&tasks)
}

func (cc TaskService) GetTaskReportByUserId(userId string, todoCount *int64, inProgressCount *int64, doneCount *int64) (todoResult *gorm.DB, inProgressResult *gorm.DB, doneResult *gorm.DB) {
	var tasks []models.Task
	queryTodo := cc.db.DB.Where("user_id = ? AND status = ?", userId, "to_do")
	queryInProgress := cc.db.DB.Where("user_id = ? AND status = ?", userId, "in_progress")
	queryDone := cc.db.DB.Where("user_id = ? AND status = ?", userId, "done")
	return queryTodo.Find(&tasks).Count(todoCount), queryInProgress.Find(&tasks).Count(inProgressCount), queryDone.Find(&tasks).Count(doneCount)
}
